---
title: "Twitter textual data: scraping and analyzing"
author: "Renato Russo"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Loading all the required packages
```{r}
library(widyr)
library(tidytext)
library(dplyr)
library(corpus)
library(tidyr)
library(forcats)
library(tm)
library(topicmodels) # visualization of topics in the NLP section
library(ggplot2) # chart of co-occurring terms
library(tidytext) # chart of co-occurring terms
library(wordcloud) #for wordcloud


```

In this community contribution, we will be looking at three broader tasks of
data analysis and visualization applied to textual data. More specifically, we
will look at Twitter datas, and see methods for **collecting (scraping)**,
**preparing**, and **analyzing** Twitter data.

### 1. Scrape data
The first thing you should do is obtaining data. Fortunately, Twitter makes it 
relatively easy to scrape data, all you need to start is a Twitter Developer
Account so you can get access to Twitter API. Actually, there are a few different
types of Developer Account. For the purpose of this project, I am using my 
Academic Research account. You may want to check out [Twitter's Developer Portal](https://developer.twitter.com/)
for more information.
From this point on, I will assume that you have your Twitter API credentials at
hand ;-)

#### Packages needed/recommended
There are a few packages that help us retrieve data from Twitter. For this project,
I am using [academictwitteR](https://www.research.ed.ac.uk/en/publications/academictwitter-an-r-package-to-access-the-twitter-academic-resea),
but you may also want to check out [twitteR](https://cran.r-project.org/web/packages/twitteR/twitteR.pdf)
and [rtweet](https://cran.rstudio.com/web/packages/rtweet/index.html). I have
already experienced a few glitches with the former, which seems to be updated less
frequently than rtweet. Another reason why I am using academictwitteR now is because
it has a more straight forward connection with Twitter API V2, which we can use 
to retrieve "historical data" (the previous API allowed retrieval of data from
the past 8-10 days only, among other limitations).
So, let's get on with the search:
```{r academictwitter install}
# install.packages("academictwitteR")
library(academictwitteR)
```
#### Set up credentials
For this step, you will have to look at your profile on Twitter's developer portal.
Now, go ahead and get your credentials.
With academictwitteR, I can use the Bearer Token only. The [API documentation](https://developer.twitter.com/en/docs/authentication/oauth-2-0/bearer-tokens)
and the [package repository](https://github.com/cjbarrie/academictwitteR) have
more information on that. For now, you have to call the function `set_bearer()` to
store that information for future use.
```{r bearer}
set_bearer()
```
Once you follow the instructions above, you are ready to go ahead and run your
query!

#### Perform the search
Now, you're finally able to run the search. For that, you will use the
`get_all_tweets()` function. In my case, I am interested in investigating how
sectors of the alt-right have "hijacked" narratives related to the Capitol attack
in January 2021, to assess what type of vocabulary people were using to refer to
different narratives related to that event.
For the purpose of this example, I will limit the number of tweets retrieved to 5000.
```{r data collection}
# capitol <- get_all_tweets(query = "capitol", # search query
#                                    start_tweets = "2021-01-06T00:00:00Z", # search start date
#                                    end_tweets = "2021-01-06T19:00:00Z", # search end date
#                                    bearer_token = get_bearer(), # pulling stored bearer toke
#                                    data_path = "data", #where data is stored as series of JSON files
#                                    n = 5000, # total number of tweets retrieved
#                                    is_retweet = FALSE) # excluding retweets
# save(capitol, file = "capitol.Rda")
load("capitol.Rda")
```
### 2. Prepare data
For this analysis, we will predominantly use the "text" column, that is, the 
content of the actual tweet. We could use other data, for example number of likes,
or the timeline of a user, but let's focus on the content for now.

#### Removing capitalization, numbers, and punctuation.
The custom function below is used to remove capitalization, and to remove numbers and 
punctuation:
```{r data cleaning function}
# First, we define the function
clean_text <- function(text) {
  text <- tolower(text)
  text <- gsub("[[:digit:]]+", "", text)
  text <- gsub("[[:punct:]]+", "", text)
  return(text)
}
# Then, apply it to the text content:
capitol$text <- clean_text(capitol$text)

```
We also want to remove stop words, that is, those that do not add meaning to
textual analysis. Before doing that, we will tokenize the words, which is a
process that will be useful in other steps further ahead:
#### Tokenize words
```{r token}
capitol_tokens <- capitol %>%
  tidytext::unnest_tokens(word, text) %>% 
  count(id, word)
```
Below, I am using ```tidytext```'s standard set of stop words:
``` {r}
capitol_tokens <- capitol_tokens %>% 
  dplyr::anti_join(tidytext::get_stopwords())

```
However, preliminary plotting showed that the word "capitol" was causing noise 
in the charts because it obviously appears in every tweet, so I decided to remove
it from the corpus. I understand that this does not harm the analysis, because we
are not interested in the connections with the word, but in the general meaning of
tweets containing that word.
```{r}
my_stopwords <- tibble(word = c(as.character(1:10),
                                    "capitol", "just", "now",
                                "right now", "get", "like"))
capitol_tokens <- capitol_tokens %>% 
  anti_join(my_stopwords)
```
I will also "stem" words, that is, combine words that share the same "root." This
is important because preliminary analysis showed the existence of words that have
similar seemantic value like "storm" and "storming"
```{r stemming}
capitol_tokens$word <- text_tokens(capitol_tokens$word, stemmer = "en") # english stemmer
```
#### Document-term matrix
The document-term matrix (dtm) is "a mathematical matrix that describes the frequency
of terms that occur in a collection of documents" [3]. In this case, each tweet
is stored as a document, and each word in the tweets is a term. In other words,
the matrix shows which words appear in each tweet.

```{r DTM}
DTM <- capitol_tokens %>%
  tidytext::cast_dtm(id, word, n)
DTM
```
Looking at the structure of the document-term matrix, we see that this specific
dtm has 17,635 documents (tweets) and 36,273 terms (unique words). The dtm will
be used for exploratory analysis in the next section.

### 3. Analyze data
#### Exploratory analysis
```{r }
capitol_tokens %>% 
  group_by(word) %>% 
  summarize(occurrence = sum(n)) %>% 
  arrange(desc(occurrence))
```
Now, we will look at the frequency of words (tokens). We can see that the 
```{r}
tokens_words <- capitol_tokens %>% # creating a data frame with the frequencies
  group_by(word) %>% 
  summarise(N = n())

tokens_words$word <- as.character(tokens_words$word) # turning the tokens into character objects
```
Below, we can see the list of words by frequency. We notice that there is a
"first tier" of frequency containing the words "storm,""build," "trump," and
"polic" are the 3 most frequent ones. "Storm," "build," and "polic" represent word
stems, so words like "building" are within the "build" term, for example.
```{r}
(tokens_words %>% 
  group_by(word) %>% 
  arrange(desc(N))
)
```
And we can plot the word frequency in a bar chart:
```{r word_frequency_chart}
tokens_words %>% 
  group_by(word) %>% 
  filter(N > 300) %>% 
  ggplot(aes(x = fct_reorder(word, N, .desc = TRUE), y = N, fill = N)) +
  geom_bar(stat = "identity") +
  ylab("Count") +
  xlab("Term (stemmed)") +
  theme_classic()
```

Another way to visualize the frequency of words is with a wordcloud. Although not
always a good choice, in this case a wordcloud allows for visualizations of other
terms that don't fit in the bar chart.
```{r}
set.seed(1234) # for reproducibility

pal <- brewer.pal(9, "BuGn") # setting the color palette
pal <- pal[-(1:5)] # this improves readability by narrowing the range of shades of the palette showing in the chart

wordcloud(words = tokens_words$word,
          freq = tokens_words$N,
          min.freq = 50,
          max.words=200,
          random.order=FALSE,
          rot.per=0.35,
          colors=pal)
```


#### Natural language processing
##### Visualize topics with Latent Dirichlet Allocation (LDA)
Latent Dirichlet Allocation is an approach to statistical topic modeling in which
documents are represented as a set of topics and a topic is a set of words. The
topics are situated in a "latent layer." Put in a very simple way, this type of
modeling compares the presence of a term in a document and in a topic, and uses
that comparison to establish the probability that the document is part of the
topic [4].
This type of modeling is used here to identify the topics and the co-occurring
terms, that is, terms that appear together in the tweets.
The code below performs the topic allocation. Initial runs of this and the following
parts revealed that the topics were too similar, so I proceeded with the creation
of only 2, which seemed to capture the meaning in tweets satisfactorily.
```{r LDA}
LDA <- topicmodels::LDA(DTM,
                        k = 2, # number of topics
                        control = list(seed = 123))

LDA_td <- tidytext::tidy(LDA) #tidying the LDA object

```
##### Visualize co-occurring terms
The code below creates a tibble containing topics of 5 terms each.
```{r}
topTerms <- LDA_td %>% 
  group_by(topic) %>% 
  top_n(5, beta) %>% # 5 main terms that will later be plotted
  arrange(topic, -beta) # arranging topics in descending order of beta coefficient
```
Then, we plot the topics.
```{r}
topTerms %>% 
  mutate(term = reorder_within(term, beta, topic)) %>% 
  ggplot(aes(term, beta, fill = factor(topic))) +
  geom_col(show.legend = FALSE) +
  facet_wrap(~ topic, scales = "free_x") +
  coord_flip() +
  scale_x_reordered() +
  labs(title = "Topics in tweets containing the term 'capitol' in January 6, 2021")
```
The process of identifying the number of topics and terms in each topic was iterative
in this case. Preliminary plotting showed that there was strong intersection between
topics, so I kept reducing the number until I found two that seemed relevant.
Apparently, topic #2 refers to the process of protesters (stem "protest") storming
the capitol building (stem "build"); conversely, topic #1 seems to refer to police
reaction to the attacks by the supporters.

Another way to visualize the relationships in the corpus is by identifying the
frequency of word pairs present in the corpus. The code below generates a data
```{r}
word_pairs_capitol <- capitol_tokens %>%
  pairwise_count(word, id, sort = TRUE, upper = FALSE)
```
```{r}
# ## Including Plots
#network of co-occurring words
library(igraph)
library(ggraph)
word_pairs_capitol %>%
  filter(n >= 80) %>%
  graph_from_data_frame() %>%
  ggraph(layout = "fr") +
  geom_edge_link(aes(edge_alpha = n, edge_width = n), edge_colour = "cyan4") +
  geom_node_point(size = 5) +
  geom_node_text(aes(label = name), repel = TRUE,
                 point.padding = unit(0.5, "lines")) +
  theme_void() +
  labs(title = "Co-occurring terms in tweets containing the term 'capitol' in January 6, 2021")

```

The plot above shows a few potentially interesting aspects of this corpus, among
which we highlight two. First, there is a cluster of words related to non-lethal
police weapons ("tear gas" and "rubber bullet"); that cluster is connected to 
"police" and and "people." Another aspect is the proximity of "trump" to the
center of the graph, strongly connected with "support" (possibly stemmed from
"supporter/s"). "Support" is also strongly connected with "build" and "storm."
This is compatible with the pairwise chart, in which one of the topics is
possibly associated with the police reaction to the attacks.


References:
[1] https://jtr13.github.io/cc21/twitter-sentiment-analysis-in-r.html#word-frequency-plot

[2] https://towardsdatascience.com/create-a-word-cloud-with-r-bde3e7422e8a

[3] DTM: https://bookdown.org/Maxine/tidy-text-mining/tidying-a-document-term-matrix.html

[4] LDA https://blog.marketmuse.com/glossary/latent-dirichlet-allocation-definition/

<!-- #### Wordcloud -->
<!-- ##### Create DTM -->
<!-- Before you create a wordcloud, you need a document-term matrix: -->
<!-- ```{r dtm} -->
<!-- library(wordcloud) -->
<!-- tweets_words <-  capitol %>% -->
<!--   select(text) %>% -->
<!--   unnest_tokens(word, text) -->

<!-- words <- capitol_tokens %>% -->
<!--   count(word, sort=TRUE) -->

<!-- words -->

<!-- set.seed(1234) # for reproducibility -->
<!-- wordcloud(words$word, words$n, min.freq = 50, -->
<!--           max.words=150, random.order=FALSE, rot.per=0.35, -->
<!--           colors=brewer.pal(8, "Dark2")) -->

<!-- #  -->
<!-- library(tm) -->
<!-- # install.packages("wordcloud") -->
<!-- library(wordcloud) -->
<!-- set.seed(1234) # for reproducibility -->

<!-- # wordcloud(words = dyor_tokens$word, freq = dyor_tokens$n, min.freq = 50, -->
<!-- #           max.words=200, random.order=FALSE, rot.per=0.35, -->
<!-- #           colors=brewer.pal(8, "Dark2")) -->
<!-- ``` -->

